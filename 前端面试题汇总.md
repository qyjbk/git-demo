# HTML

## 前端语义化具体表现在哪里

语义化优点：代码结构清晰，易于阅读，利于开发维护

​			  提高用户体验，样式加载失败时，页面结构清晰

​			    方便于其他设备解析，根据语义渲染网页

​			  有利于搜索引擎优化(seo)，搜索引擎爬虫会根据不同标签来赋予不同的权重

语义化标签有：

​			title,header,nav,main,article,h1-h6,ul,ol,address,canvas,dialog,aside,section,figure,details,mark

## 常见浏览器及其内核

谷歌浏览器（Blink），IE(trident)，火狐浏览器(gecko)，苹果浏览器(webkit)，opear(Blink)

# CSS

## BFC

BFC为"块级格式化上下文"，是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。

### BFC的布局规则

内部的Box会在垂直方向，一个接一个地放置。

Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。

每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。

BFC的区域不会与float box重叠。

BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。

计算BFC的高度时，浮动元素也参与计算。

### 如何创建BFC

1、float的值不是none。
2、position的值不是static或者relative。
3、display的值是inline-block、table-cell、flex、table-caption或者inline-flex
4、overflow的值不是visible

### 总结

因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。


## 权重的等级有哪些以及如何计算权重？

可以把样式的应用方式分为几个等级，按照等级来计算权重

1、!important，加在样式属性值后，权重值为 10000
2、内联样式，如：style=””，权重值为1000
3、ID选择器，如：#content，权重值为100
4、类，伪类和属性选择器，如： content、:hover 权重值为10
5、标签选择器和伪元素选择器，如：div、p、:before 权重值为1
6、通用选择器（*）、子选择器（>）、相邻选择器（+）、同胞选择器（~）、权重值为0

### **块级元素与行内元素的区别**：

### 常见块元素：h1-h6,ul,ol,li,p,div,table

只有文字才能组成段落，因此p标签里面不能放块级元素，特别是p标签不能放div。同理还有这些标签h1,h2,h3,h4,h5,h6,dt，他们都是文字类块级标签，里面不能放其他块级元素。

特点：从新的一行开始，即各个块级元素独占一行，默认垂直向下排列，

​			高度、宽度、margin及padding都是可控的，设置有效，有边距效果，

​			宽度没有设置时，默认是容器（父级宽度）为100%，

​			块级元素中可以包含块级元素和行内元素。

### 常见行内元素：a,br,lable,span,strong

特点：相邻行内元素在一行上，一行可以显示多个。

​			默认宽度就是它本身内容的宽度。

​			行内元素只能容纳文本或则其他行内元素。

​			高度、宽度是不可控的，设置无效，由内容决定。

​			链接里面不能再放链接。

·			特殊情况a里面可以放块级元素，但是给a转换一下块级模式最安全。

### 常见行内块元素：img ，input， td

特点：和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。一行可以显示多个

​			默认宽度就是它本身内容的宽度。

​			高度，行高、外边距以及内边距都可以控制。

块转行内：display:inline，行内转块：display:block，块，行内转行内块：display:inline-block

当为行内元素进行定位时，position:absolute与position:fixed.都会使得原先的行内元素变为块级元素。

当把行内元素设置完float:left/right后，该行内元素的display属性会被赋予block值，且拥有浮动特性。行内元素去除了之间的莫名空白。



## CSS3新增

1. border-radius圆角边框
2. box-shadow盒阴影
3. background-image属性添加背景图片
4. background-size指定背景图像的大小
5. 渐变（gradients），分为线性渐变（Linear Gradients）和径向渐变（Radial Gradients）
6. 盒模型

# 前端html隐藏元素方式,CSS 隐藏元素的五种方法

### overflow:hidden

元素溢出部分隐藏，占位，不响应点击事件。

### opacity:0；

设置元素透明度的，0就是视觉隐藏了。占位，响应点击事件。

### visibility:hidden

元素隐藏了，但是占位，不响应点击事件。

### display:none

真正的隐藏，不占位，不影响布局，不响应点击事件。

### position:absolute

将元素移出可视区域。不影响布局，有能让元素保持可以操作。

## 盒模型

首先，盒模型一共有2种模式，分别是 符合W3C标准的‘标准盒模型’ 和 在IE下的‘IE盒模型’。

首先，两种模式可以利用box-sizing属性进行自行选择：

　　标准模式：box-sizing:content-box;

　　IE模式：box-sizing:border-box;

两种模式的区别：

　　标准模式会被设置的padding撑开，而怪异模式则相当于将盒子的大小固定好，再将内容装入盒子。盒子的大小并不会被padding所撑开。

标准模式：盒子总宽度/高度 = 内容区宽度 /高度+padding+border + margin。

怪异模式：盒子总宽度/高度 = width/height + margin。

## 盒子垂直居中的五个方法

### 第一种，常用于垂直居中盒子的文字，需要知道盒子高度，行高不能设置百分比

```
text-align:center;
line-height:height(盒子高度)
```

### 第二种，使用display:table和display:table-cell配合，两个必须分别作用于父盒子和子盒子

```
display:table-cell;
vertical-align:middle;
```

### 第三种，使用flex布局，不需要知道宽高，写在父盒子

```
display:flex;
justify-content:center;
align-items:center;
```

### 第四种，使用position绝对定位

```
position:absolute;
top:0;
right:0;
bottom:0;
left:0;
margin:auto;
```

### 第五种，也是使用position绝对定位

```
position:absolute;
top:50%;
left:50%;
transform:translate(-50%, -50%);
```

## Flex布局

Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。

任何一个容器都可以指定为Flex布局。

### 容器的属性

- flex-direction
- flex-wrap
- flex-flow
- justify-content
- align-items
- align-content

### flex-direction属性决定主轴的方向（即项目的排列方向）。

row（默认值）：主轴为水平方向，起点在左端。
row-reverse：主轴为水平方向，起点在右端。
column：主轴为垂直方向，起点在上沿。
column-reverse：主轴为垂直方向，起点在下沿。

### flex-wrap属性

nowrap（默认）：不换行。

wrap：换行，第一行在上方。

wrap-reverse：换行，第一行在下方。

### flex-flow

flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。

### justify-content属性

- flex-start（默认值）：左对齐
- flex-end：右对齐
- center： 居中
- space-between：两端对齐，项目之间的间隔都相等。
- space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。

### align-items属性

align-items属性定义项目在交叉轴上如何对齐。

- flex-start：交叉轴的起点对齐。
- flex-end：交叉轴的终点对齐。
- center：交叉轴的中点对齐。
- baseline: 项目的第一行文字的基线对齐。
- stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。

### align-content属性

align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。

- flex-start：与交叉轴的起点对齐。
- flex-end：与交叉轴的终点对齐。
- center：与交叉轴的中点对齐。
- space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
- space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
- stretch（默认值）：轴线占满整个交叉轴。

### 项目的属性

- order
- flex-grow
- flex-shrink
- flex-basis
- flex
- align-self

### order属性

order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。

### flex-grow属性

flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。

如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。

### flex-shrink属性

flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。

如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。

负值对该属性无效。

### flex-basis属性

flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。

它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。

### flex属性

flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。

该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。

建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。

### align-self属性

align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。

该属性可能取6个值，除了auto，其他都与align-items属性完全一致。

## px、em、rem区别

它们都是用于设置字体的大小以及盒子的宽高，但是px不会因为浏览器尺寸的改变而改变，而em和rem会因为浏览器尺寸的变化而变化。

px 是 pixel 的缩写，它的含义是像素的意思，在指定字体大小和元素的宽高的时候使用。像素是相对于显示器屏幕分辨率而言的。

em是一个相对长度的单位，是相对于当前对象内文本的字体尺寸。如过我们未设置当前文本的字体尺寸，那么em就会相对于浏览器的默认字体尺寸

在浏览器中默认字体尺寸为16px，换句话说1em=16px,一般我们在写自适应布局时经常会用到em为单位。通过在CSS中的body选择器中设置font-size值来简化代码，使得页面中所有的em都相对于body值。

em的值并不是固定的而且是相对于他的父级元素大小。

rem是CSS3中新增的一个相对单位，它与em的区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。它的使用非常简单，通过改变根元素fountSixe的大小就可以改变它的值。

# JS

## 模块化

### 无模块化-->CommonJS规范-->AMD规范-->CMD规范-->ES6模块化

### 无模块化

- 污染全局作用域
- 维护成本高
- 依赖关系不明显

### CommonJS规范

解决了依赖、全局变量污染的问题，CommonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，**CommonJS不适合浏览器端模块加载**，更合理的方案是使用异步加载，比如下边AMD规范。

### AMD规范

AMD规范则是非同步加载模块，允许指定回调函数，适合在浏览器环境中异步加载模块、并行加载多个模块，不能按需加载、开发成本大

### CMD规范

CMD是按需加载，就近原则。

### ES6模块化

一个模块只能有一个`export default`。

```jsx
  在ES6中，我们可以使用 import 关键字引入模块，通过 exprot 关键字导出模块，功能较之于前几个方案更为强大，也是我们所推崇的，**但是由于ES6目前无法在浏览器中执行，所以，我们只能通过babel将不被支持的import编译为当前受到广泛支持的 require**。 
```

```cpp
  es6在导出的时候有一个默认导出，`export default`,使用它导出后，在import的时候，不需要加上{}，模块名字可以随意起。该名字实际上就是个对象，包含导出模块里面的函数或者变量。
```

###  CommonJs和ES6区别

以下引用阮一峰老师的内容：

#### （1） CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。

- CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。
- ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令`import`，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的`import`有点像 Unix 系统的“符号连接”，原始值变了，`import`加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。

#### （2） CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

- 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。
- 编译时加载: ES6 模块不是对象，而是通过 `export` 命令显式指定输出的代码，`import`时采用静态命令的形式。即在`import`时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。

CommonJS 加载的是一个对象（即`module.exports`属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

## GET 和 POST 请求区别。

Form 中的 get 和 post 方法，在数据传输过程中分别对应了 HTTP 协议中的 GET 和 POST 方法。二者主要区别如下：

-  1、Get 是用来从服务器上获得数据，而 Post 是用来向服务器上传递数据。
-  2、Get 将数据的按照键值对的形式，添加到地址栏 后面，使用“?”连接，而多个变量之间使用“&”连接；Post 是将表单中的数据放在 form 的数据体中，按照变量和值相对应的方式，传递到 action 所指向 URL。
-  3、Get 是不安全的，因为请求的参数都显示在了地址栏中，Post 的所有操作对用户来说都是不可见的。
-  4、Get 传输的数据量小，URL 长度限制；而 Post 相对没有限制，可以传输大量的数据。

使用 Post 传输的数据，可以通过设置编码的方式正确转化中文；而 Get 传输的数据却没有变化。在以后的程序中，我们一定要注意这一点。

## 数据类型有哪些？null和undefined的区别，他们type of的结果是什么

**值类型(基本类型)**：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。

**引用数据类型**：对象(Object)、数组(Array)、函数(Function)。

*Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。*

null为空， undefined 是未定义的，type of都是object

## 微任务和宏任务

- **macro-task(宏任务)**：包括整体代码script，setTimeout，setInterval
- **micro-task(微任务)**：Promise，process.nextTick

不同类型的任务会进入不同的Event Queue，有宏任务的队列和微任务的队列。

## 原理：单线程、任务队列以及事件循环（event loop）

单线程

JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。

任务队列

单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。

如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。

JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。

于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

1. 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
2. 主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
3. 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
4. 主线程不断重复上面的第三步。

只要主线程空了，就会去读取"任务队列"，这就是JavaScript的运行机制。这个过程会不断重复。

"任务队列"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入"任务队列"，等待主线程读取。

事件循环（event loop）

主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。

## 原型、原型链

var  p   =   new  person()   p为构造函数person()创建的实例对象

原型链继承：构造函数创建的实例对象可以直接去访问(继承)构造函数的prototype属性上的任意成员

function person() { }

​        person.prototype.color = 'lime'

​        var p = new person()

​        console.log(p.color);// lime

当继承的方法很多时，一个一个在原型上添加比较繁琐，所以用到原型替换

原型替换：把原型对象替换成新对象，在新对象里面添加需要的方法

function person() { }

​        person.prototype = {

​            color: function () {

​                console.log('red');

​            }

​        }

​        var p = new person()

​        p.color()

但是原型替换有问题，造成constructor丢失

解决方法：给原型替换的新对象添加constructor即可

function person() { }

​        person.prototype = {

​            constructor: person,

​            color: function () {

​                console.log('red');

​            }

​        }

​        var p = new person()

​        p.color()

​        console.log(p.constructor);// person

## this指向问题

1. 谁调用this所在 的函数, this就指向谁  ★

2. call  apply  bind  (Function.prototype)  改变this指向★

3. 箭头函数里面没有自己的this, this指向外面的 ★

 ==> 箭头函数不能当构造函数使用

1. call 和 apply ===> 立即调用 + 改变指向

2. bind   ==> 返回一个新函数 + 改变指向

**call**

非严格模式

如果不传参数，或者第一个参数是`null`或`nudefined`，`this`都指向`window`

严格模式

第一个参数是谁，this就指向谁，包括null和undefined，如果不传参数this就是undefined

**apply**

apply把需要传递给fn的参数放到一个数组（或者类数组）中传递进去，虽然写的是一个数组，但是也相当于给fn一个个的传递

**bind**

bind：会返回的是一个修改过后新的函数，而且不是立即调用

## 数组去重：

1、function Fn(arr){
​        var newArr = [];
​        for(var i = 0; i < arr.length; i++){
​            if(newArr.indexOf(arr[i]) == -1){
​                        newArr.push(arr[i]);
​                }
​        }
​        return newArr;
​    }

let  arr = [2,8,4,2,3,4,3,1,5,8]

console.log(Fn(arr))

原理：用一个空数组去存首次 出现的元素 
利用 indexOf 属性 indexOf是返回某个指定的字符在字符串中出现的位置，如果没有就会返回-1 
因此我们可以很好的利用这个属性 当返回的是 -1时 就让其存入数组

2、let arr = [5, 6, 2, 2, 2, 3, 3, 3]

let   res = new Set(arr)==>简写 res = [...new Set(arr)]

 console.log(res);

拓展运算符(. . .)内部使用for. . . of循环

3、function Fn(arr) {

​		return Array.from(new Set(arr))

​            }

console.log(Fn(arr))

Array.from方法可以将Set结构转换为数组结果，而我们知道set结果是不重复的数据集，因此能够达到去重的目的

4、利用includes(包含)

5、利用filter

```js
function unique(arr) {
  return arr.filter(function(item, index, arr) {
    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素
    return arr.indexOf(item, 0) === index;
  });
}
```

## JS数组方法

split()

join()
push()和pop()
shift() 和 unshift()
sort()
reverse()
concat()
slice()
splice()
indexOf()和 lastIndexOf() （ES5新增）
forEach() （ES5新增）
map() （ES5新增）
filter() （ES5新增）
every() （ES5新增）
some() （ES5新增）
reduce()和 reduceRight() （ES5新增）

split():通过指定分隔符对字符串进行分割，返回分割后的字符串列表

1、join()只接收一个参数：分隔符，还可以实现重复字符串，只需要传入字符串和重复次数就能返回重复后的字符串

function fn(str, n) {

​            return new Array(n + 1).join(str)

​        }

​        console.log(fn('abc', 3));// abcabcabc

​        console.log(fn('hellow', 3));// hellowhellowhellow

2、push()和pop()

push():可以接收任意数量的参数，把他们逐个添加到数组末尾，并返回修改后数组的长度

pop()：数组末尾移除最后一项，减少数组的length值，然后返回移除的项

var arr = [1, 2, 3, 4, 5, 6]

 var count = arr.push(7)

​        console.log(count);// 7

​        console.log(arr);// [1, 2, 3, 4, 5, 6, 7]

 var item = arr.pop()

​        console.log(item);// 7

​        console.log(arr);// [1, 2, 3, 4, 5, 6]

3、shift()和unshift()

shift():删除原数组第一项，并返回删除元素的值，如果数组为空则返回undefined

unshift()：将参数添加到原数组开头，并返回数组长度

var arr = [1, 2, 3, 4, 5, 6]

var count = arr.unshift(7, 8)

​        console.log(count);// 7

​        console.log(arr);// [7, 8, 1, 2, 3, 4, 5, 6]

var item = arr.shift()

​        console.log(item);// 7

​        console.log(arr);// [8, 1, 2, 3, 4, 5, 6]

4、sort()

sort()按升序排列数组项---即最小值位于最前面，最大值排在最后面

在排序时，sort()方法会调用数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序

即使数组中的每一项都是数值，sort()方法比较的也是字符串，因此会出现下面这种情况

var arr1 = ['a', 'b', 'c', 'd']

​        console.log(arr1.sort());// ['a', 'b', 'c', 'd']

​        var arr2 = [13, 24, 51, 3]

​        console.log(arr2.sort());// [13, 24, 3, 51] (原数组被改变)

为了解决上述问题，sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值前面

比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0,

如果第一个参数应该位于第二个之后则返回一个正数。

function fn(v1, v2) {

​            if (v1 < v2) {

​                return -1

​            } else if (v1 > v2) {

​                return 1

​            } else {

​                return 0

​            }

​        }

​        arr2 = [13, 24, 51, 3]

​        console.log(arr2.sort(fn));

如果需要通过比较函数产生降序的结果，只要交换比较函数返回的值即可

function fn(v1, v2) {

​            if (v1 < v2) {

​                return 1

​            } else if (v1 > v2) {

​                return -1

​            } else {

​                return 0

​            }

​        }

​        arr2 = [13, 24, 51, 3]

​        console.log(arr2.sort(fn));// [51, 24, 13, 3]

5、reverse()

reverse()：反转数组项的顺序

var arr = [1, 3, 5, 7, 9, 11, 13]

​        console.log(arr.reverse());//[13, 11, 9, 7, 5, 3, 1]

​        console.log(arr);//[13, 11, 9, 7, 5, 3, 1]  (原数组被改变)

6、concat()

concat()：将参数添加到原数组中。这个方法会先创建当前数组的一个副本，然后将接收到的参数添加到

这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回本。

var arr = [1, 3, 5, 7, 9, 11, 13]

​        var fn = arr.concat(9, [11, 13])

​        console.log(fn);// [1, 3, 5, 7, 9, 11, 13, 9, 11, 13]

​        console.log(arr);// [1, 3, 5, 7, 9, 11, 13]

从上面测试结果可以发现：传入的不是数组，则直接把参数添加到数组后面，如果传入的是数组，则将数组中的各个项添加到数组中。但是如果传入的是一个二维数组呢？

var arrCopy2 = arr.concat([9,[11,13]]);
console.log(arrCopy2);   //[1, 3, 5, 7, 9, Array[2]]
console.log(arrCopy2[5]);   //[11, 13]

上述代码中，arrCopy2数组的第五项是一个包含两项的数组，也就是说concat方法只能将传入数组中的每一项添加到数组中，如果传入数组中有些项是数组，那么也会把这一数组项当作一项添加到arrCopy2中。

7、slice()

slice()：返回从原数组中指定开始下标到结束下标之间的项组成新的数组。slice()方法可以接收一个或者两个参数，即要返回项的起始和结束位置。只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项，但是不包括结束位置的项

var arr = [1,3,5,7,9,11];
var arrCopy = arr.slice(1);
var arrCopy2 = arr.slice(1,4);
var arrCopy3 = arr.slice(1,-2);
var arrCopy4 = arr.slice(-4,-1);
console.log(arr);   //[1, 3, 5, 7, 9, 11] (原数组没变)
console.log(arrCopy);   //[3, 5, 7, 9, 11]
console.log(arrCopy2);   //[3, 5, 7]
console.log(arrCopy3);   //[3, 5, 7]
console.log(arrCopy4);   //[5, 7, 9]

arrCopy只设置了一个参数，也就是起始下标为1，所以返回的数组为下标1（包括下标1）开始到数组最后。
 arrCopy2设置了两个参数，返回起始下标（包括1）开始到终止下标（不包括4）的子数组。
 arrCopy3设置了两个参数，终止下标为负数，当出现负数时，将负数加上数组长度的值（6）来替换该位置的数，因此就是从1开始到4（不包括）的子数组。
 arrCopy4中两个参数都是负数，所以都加上数组长度6转换成正数，因此相当于slice(2,5)。

8、splice()

splice()：很强大的数组方法，它可以实现删除，插入和替换

删除：可以删除任意数量的项，只需要指定2个参数：要删除的第一项的位置和要删除的项数。

例如splice(0,2)会删除数组前两项

插入：可以指定位置插入任意数量的项，只需要提供三个参数：

起始位置、0(要删除的项数)和要插入的项。

例如：splice(2,0,4,6)会从当前数组的位置2开始插入4和6

替换：可以指定位置插入任意数量的项，同时删除任意数量的项，只需要三个参数：

起始位置、要删除的项数和要插入的任意数量的项。

插入的项数不必与删除的项数相等。

例如：splice(2,1,4,6)会删除当前数组位置2的项，然后再从位置2 开始插入4和6

splice()方法始终都会返回一个数组，该数组中包含从原数组中删除的项，如果没有删除任何项，则返回一个空数组

var arr = [1,3,5,7,9,11];
var arrRemoved = arr.splice(0,2);
console.log(arr);   //[5, 7, 9, 11]
console.log(arrRemoved);   //[1, 3]
var arrRemoved2 = arr.splice(2,0,4,6);
console.log(arr);   // [5, 7, 4, 6, 9, 11]
console.log(arrRemoved2);   // []
var arrRemoved3 = arr.splice(1,1,2,4);
console.log(arr);   // [5, 2, 4, 4, 6, 9, 11]
console.log(arrRemoved3);   //[7]

9、indexof()和lastIndexof()

indexof():接收两个参数：要查找的项的和(可选的)表示查找起点位置的索引。

其中，从数组开头(位置0)开始向后找

lastIndexof()：接收两个参数：要查找的项的和(可选的)表示查找起点位置的索引。

其中，从数组末尾开始前后找

这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用全等操作符。

var arr = [1,3,5,7,7,5,3,1];
console.log(arr.indexOf(5));   //2
console.log(arr.lastIndexOf(5));   //5
console.log(arr.indexOf(5,2));   //2
console.log(arr.lastIndexOf(5,4));   //2
console.log(arr.indexOf("5"));   //-1

10、forEach()

forEach():对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容； 第对应的数组索引，数组本身。

var arr = [1, 2, 3, 4, 5];
arr.forEach(function(x, index, a){
​	console.log(x + '|' + index + '|' + (a === arr));
});
输出为：
 1|0|true
 2|1|true
 3|2|true
 4|3|true
 5|4|true

11、map()

map():指映射，对数组中的每一项运行给定函数，每次函数调用的结果组成的数组

下面代码利用map方法实现数组中每个数求平方。

var arr = [1, 2, 3, 4, 5];
var arr2 = arr.map(function(item){
​	return item*item;
});
console.log(arr2);  //[1, 4, 9, 16, 25]

12、filter()

filter()“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组

var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var arr2 = arr.filter(function(x, index) {
​	return index % 3 === 0 || x >= 8;
}); 
console.log(arr2);  //[1, 4, 7, 8, 9, 10]

13、every()
 every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。

var arr = [1, 2, 3, 4, 5];
var arr2 = arr.every(function(x) {
​	return x < 10;
}); 
console.log(arr2);  //true
var arr3 = arr.every(function(x) {
​	return x < 3;
}); 
console.log(arr3);  // false

14、some()
 some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。

var arr = [1, 2, 3, 4, 5];
var arr2 = arr.some(function(x) {
​	return x < 3;
}); 
console.log(arr2);  //true
var arr3 = arr.some(function(x) {
​	return x < 1;
}); 
console.log(arr3);  // false

15、reduce()和 reduceRight()
 这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。
 这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。
 传给 reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。
 下面代码用reduce()实现数组求和，数组一开始加了一个初始值10。

var values = [1,2,3,4,5];
var sum = values.reduceRight(function(prev, cur, index, array){
​	return prev + cur;
},10);
console.log(sum);  //25

## 说一下闭包的优缺点，缺点怎么解决

闭包具有封闭性和持久性，缺点就是常驻内存 会增大内存的使用量 使用不当会造成内存泄露

解决方法是，在退出函数之前，将不使用的局部变量全部删除

## js手写闭包，递归，深拷贝

闭包就是函数里面还有函数，内部函数可以访问到外部包裹的函数的变量

<button></button>

<button></button>

<button></button>

<button></button>

var btns = document.querySelectorAll("button")

for (var i = 0; i < btns.length; i ++) {

​	 function fn(j) {

​		btn[j]// 每一个按钮

​		btn[j].onclick = function () {

​			console.log(j)

​		}

​	}

​	fn(i)

}

递归函数就是自己调用自己，不能一直调用，需要结束递归的条件

function fn() {

​	console.log("fn is ok")

​	fn()

}

fn()

添加一个判断条件，使其停止调用

const count = 0

function fn() {

​	count ++

​	console.log("fn is ok", count)

​	if (count < 5) {

​		fn()

​	}

}

fn()

深拷贝：需要拷贝的对象为复杂类型的

拷贝对象多层属性，对象还有对象

还是做判断，如果里面有复杂类型的再次拷贝

function copy(obj) {

​	var newObj = {}

​	for (var k in obj) {

​		if (typeof obj[k] === "object") {

​			newObj[k] = copy(obj[k])

​		} else {

​			newObj[k] = obj[k]

​		}

​	}

​	return newObj

}

# async，await和Promise比较

async搭配await是ES7提出的，它的实现是基于Promise，通过同步方式的写法，使得代码更容易阅读。

Promise是ES6的新特性，用于处理异步操作逻辑和回调地狱，用过给Promise添加then和catch函数，处理成功和失败的情况

Promise有三种状态：pending（执行中）、success（成功）、rejected（失败）

promise 出现解决了传统 callback 函数回调地域的问题，支持链式调用可以停.then,promise 分别有 3 种状态一旦函数执行 promise 有了结果就无法改变，遇到复杂的业务逻辑 promise 显然不是那么方便需要不停 then 这样语法显然也不美观。

async,await 是基于 promise 实现的，它是基于 Generator 函数的语法糖，它拥有内置执行器，它返回的是一个 promise 对象，可以使异步代码看起来像同步代码一样，更方便阅读和理解代码，解决了 promise 里面不停.then 的问题

## ajax原理及过程

### 原理：

Ajax的工作原理相当于在用户和服务器之间加了—个中间层(AJAX引擎)，使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器。像—些数据验证和数据处理等都交给Ajax引擎自己来做,，只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。

### 过程：

利用XMLHttpRequest对象发送简单请求的基本步骤：
1)创建XMLHttpRequest对象实例
2)设定XMLHttpRequest对象的回调函数，利用onreadystatechange属性
 3)设定请求属性:设定HTTP方法(GET或POST);设定目标URL，利用open()方法
4)将请求发送给服务器。利用send()方法
利用DOM对服务器响应进行处理

## axios

1.什么是axios

axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端。简单的理解就是ajax的封装

它本身具有以下特征：

​     a.从浏览器中创建 XMLHttpRequest
​     b.从 node.js 发出 http 请求
​     c.支持 Promise API
​     e.拦截请求和响应
​     f.转换请求和响应数据
​    g.取消请求
​    h.自动转换JSON数据

​    i.客户端支持防止 CSRF/XSRF

对于vue来说为了方便发送请求一般会先挂载再vue原型上，vue.prototype.$axios = axios

在页面通过this.$axios.get(接口地址，参数)，this.$axios.post(接口地址，parmes: {参数})请求后台数据

通过axios.defults.baseURL = "基准地址"

## Promise

promise 是es6的新语法，用于创建一个promise对象

const p = new Promise(function(resolve, reject) {

 resolve 和 reject 是两个函数。

//   我们在方法体里面实现异步逻辑。

//   当异步逻辑 成功的时候 我们调用 resolve方法，并且可以把成功的数据传递出来。

//   当我们异步逻辑失败的时候 我们调用 reject 方法，并且可以把错误新传递出来。

  fs.readFile('a.txt', 'utf8', (err, data) => {

​    if (err) return reject(err)

​    resolve(data)

  })

})

// then 成功的时候会调用

// catch 失败的时候会调用

p.then(function(data) {

  console.log(data)

}).catch(function(err) {

  console.log(err)

})

### Promise.all()方法

### 多用于并发请求需同时拿到结果再执行的一个请求方法

1. `const p = Promise.all([p1, p2, p3]);`
2. `Promise.all`方法接受一个[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)作为参数，`p1`、`p2`、`p3`都是 Promise 实例，如果不是，就会先调用下面讲到的`Promise.resolve`方法，将参数转为 Promise 实例
3. `Promise.all`方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。

# H5新增特性

canvas元素绘画，audio，video

语义化标签：article，footer，header，nav，section

表单控件：calendar，date，time，email，url，search

本地离线存储：localstorage，sessionstorage

input其他类型：text文本输入框，password密码框，button按钮，checkbox复选，radio单选，submit提交，reset重置

file文件，url地址

流式布局：百分比布局

媒体查询

# ES6新增

### let,const，模板字符串，解构，箭头函数，for of循环，map映射，reduce汇总求和，模块化，exprot default 默认导出，import A  from './A.js'导入，Promise，Set, 对象扩展

**let**：

作用：声明变量。用法类似于var，但它所声明的变量，只在let命令所在的代码块内有效。

不存在变量提升，变量一定要在声明后使用，否则报错。

不允许重复声明，let不允许在相同作用域内，重复声明同一个变量。

**const** 声明一个只读的常量。一旦声明，常量的值就不能改变。作用域与let命令相同：只在声明所在的块级作用域内有效，不提升，不可重复声明。

For...of循环：可以这样用它来循环数组，甚至能用它来循环字符串。

includes:返回布尔值，表示是否找到字符串。

startsWith:返回布尔值，表示字符串是否在源字符串的头部位置。

endsWith:返回布尔值，表示参数字符串是否在源字符串尾部。

三个方法都支持第二个参数，表示开始搜索的位置。

字符串操作新增repeat方法，返回一个新字符串，表示将源字符串重复多少次。

**变量解构赋值**

ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。

如果解构不成功，变量的值就等于undefined。

**字符串的扩展**

**模板字符串**

**模板字符串（template string）是增强版的字符串，用反引号（`）标识。**它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。

**字符串的正则方法**

字符串对象共有4个方法，可以使用正则表达式：match()、replace()、search()和split()。

ES6将这4个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。

**数组的扩展**

（1）Array.from()：用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。

（2）Array.of()：用于将一组值，转换为数组。

（3）数组实例的copyWithin()：在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。使用这个方法，会修改当前数组。

（4）数组实例的find()：用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。

（5）数组实例的findIndex()：用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。

（6）数组实例的fill()：fill方法使用给定值，填充一个数组，用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。

（7）数组实例的遍历方法entries()，keys()和values():

ES6提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象，可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。

（8）数组实例的includes()：返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。该方法属于ES7，但Babel转码器已经支持。

没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相当运算符（===）进行判断，这会导致对NaN的误判。includes就没有这些问题。

另外，Map和Set数据结构有一个has方法，需要注意与includes区分。Map结构的has方法，是用来查找键名的，Set结构的has方法，是用来查找值的。

**扩展运算符**

替代数组的apply方法，合并数组，与解构赋值结合，将字符串转为真正的数组

**函数的name属性**

返回该函数的函数名。

**箭头函数**

**ES6允许使用“箭头”（=>）定义函数。**

**箭头函数的使用注意点：**

（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。

（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。

（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。

（4）不可以使用yield命令，因此箭头函数不能用作Generator函数。

上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。

**Symbol数据类型**

S5的对象属性名都是字符串，这容易造成属性名冲突。比如，使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证**每个属性的名字都是独一无二的**就好了，这样就从根本上防止属性名的冲突。这就是ES6引入Symbol的原因。

ES6引入了一种**新的原始数据类型Symbol，表示独一无二的值**。它是JavaScript语言的第七种数据类型，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。

Symbol值通过**Symbol函数生成。**这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。

注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象。也就是说，由于Symbol值不是对象，所以不能添加属性。基本上，它是一种**类似于字符串的数据类型**。Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。

# VUE

## vue的生命周期

一共有11个，常用的有八个，分别是创建前后，渲染前后，更新前后，销毁前后

beforeCreate(数据挂载之前执行，此时没有数据)

created(数据挂载之后执行，此时有数据)

beforeMount(DOM渲染前执行)

mounted(DOM渲染后执行)

beforeUpdate(数据更新前DOM渲染前执行)

updated(数据更新后DOM渲染后执行)

beforeDestroy(当前实例销毁前执行)

destroyed(当前实例销毁后执行)

## vue组件第一次加载触发的生命周期函数

beforeCreate，created，beforeMount，mounted

# Vue 的父组件和子组件生命周期钩子函数执行顺序

- 父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted

注意 `mounted` 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 `mounted` 内部使用 [vm.$nextTick](https://cn.vuejs.org/v2/api/#vm-nextTick)，

- 子组件更新过程

  父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated

- 父组件更新过程

  父 beforeUpdate -> 父 updated

- 销毁过程

  父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed

## VUE中的data为什么是一个函数

Object是引用数据类型,如果不用function 返回,每个组件的data 都是内存的同一个地址,一个数据改变了其他也改变了;

javascipt只有函数构成[作用域](https://so.csdn.net/so/search?q=作用域&spm=1001.2101.3001.7020)(注意理解作用域,只有`函数的{}`构成作用域,`对象的{}`以及 `if(){}`都不构成作用域)，data是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立,不会相互影响

## vue中的MVVM模式是什么

即Model-View-ViewModel

Model代表数据模型，也可以在model中定义数据修改和操作业务逻辑	View代表UI组件，它负责将数据模型转化成UI展现出来

ViewModel监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View和Model的对象，连接Model和View

在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。
​	ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。

## vue常用的指令

​	v-on：注册事件

​	v-model:双向数据绑定

​	v-if、v-show、v-else：条件渲染

​	v-bind：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM

​	v-for：遍历数据

​	v-html、v-text:更新元素

​	v-cloak：提升用户体验，可解决页面渲染数据闪烁的问题

​	v-pre:没有vue指令的区域直接跳过

​	v-once:vue管理的范围只渲染一次

## vue的自定义指令

参数一：指令名字，参数二：对象，定义指令的配置，对象里可以配置5个钩子函数，我们常用三个

bind:只会执行一次，当指令和元素绑定时

inserted：指令所在元素在页面中渲染

update：指令的值发生了更新，就会执行

钩子函数中有两个参数，分别是el绑定指令的元素，binding包含指令中所有信息

Vue.directive('focus' ,  { 

​	inserted(el) {

​		el.focus()

​		}

​	})

## vue的修饰符

1.事件修饰符：

- .stop 阻止单机事件冒泡

- .prevent 阻止默认行为（比如 @submit.prevent 会阻止提交后刷新页面）

- .capture 添加事件侦听器时使用捕获模式

- .self 只有事件在元素本身（而不是子元素）触发时触发回调

- .once 只触发一次（组件也适用）

- .key 触发事件的按键

  2.v-model 修饰符：

  - .lazy
    在输入框中，默认是在input事件中同步输入框的数据，使用 lazy修饰符会转变为在change事件中同步（失去焦点或按回车才更新）。

  - . number

    将输入转换为Number类型，默认是String

  - .trim 自动过滤输入的首尾空格

按键修饰符：

1、 .enter  （回车键）

2、 .tab     

3、.delete  （捕获”删除“和”退格“键）

4、 .esc      （退出键）

5、 .space  （空格键）

6、  . up      

7、  .dowm   

8、  .left   

9、  .right  （右箭头） 

## vue插槽

默认插槽：<slot><slot/>，直接传值即可

具名插槽：<slot name="title"><slot/>,多个插槽使用需要根据插槽的name值，进行传值渲染不同的插槽

<组件名><template v-slot:title><template/><组件名/>, v-slot:  可以简写为#,

作用域插槽：<slot money="100" car="小黄车" name="title"><slot/>,插槽标签带有数据，可以把插槽的数据

一起渲染出来，<组件名><template v-slot:title="spcoed">{{spcoed.money}}<template/><组件名/>

# vue 中v-if v-for为什么不能写一起

v-for优先级比v-if高，永远不要把 v-if 和 v-for 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）

如果避免出现这种情况，则在外层嵌套template（页面渲染不生成dom节点），在这一层进行v-if判断，然后在内部进行v-for循环，如果条件出现在循环内部，可通过计算属性computed提前过滤掉那些不需要显示的项。

### vue.nextTick():在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。

简单的理解是：**当数据更新了，在dom中渲染后，自动执行该函数，**

更改数据后当你想立即使用js操作新的视图的时候需要使用它

## Mixin(混入)

var mixin = {}，new Vue({  mixins: [mixin]}）

Mixin多用于代码复用

一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。

### 选项合并

数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。

同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子**之前**调用。

值为对象的选项，例如 `methods`、`components` 和 `directives`，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。

### 全局混入

混入也可以进行全局注册。

使用全局混入，它将影响**每一个**之后创建的 Vue 实例。

可以用来为自定义选项注入处理逻辑。

## 递归组件的用法

- 全局注册递归组件

```js
// 递归组件： 在组件中渲染组件本身，一定要有渲染的条件（某种情况下不进行渲染）
    Vue.component('demo', {
      template: `
        <div class="demo">
          <h3>我是demo组件</h3>
          <demo></demo>
        </div>
      `
    })
```

- 局部注册递归组件

==如果是局部注册，需要提供name属性的==

```js
const vm = new Vue({
  el: '#app',
  data: {
    msg: 'hello'
  },
  components: {
    demo: {
      name: 'demo',
      template: `
        <div class="demo">
          <h3>我是demo组件</h3>
          <demo></demo>
        </div>
      `,
    }
  }
})
```

- 递归组件一定要有结束条件

```js
<demo v-if="Math.random() > 0.5"></demo>
```

## Vue高阶用法：provide 和 inject

provide和inject是成对出现的

**作用**：用于父组件向子孙组件传递数据，

**用法**：provide在父组件中返回要传给下级的数据，inject在需要使用这个数据的子辈组件或者孙辈等下级组件中注入数据。

**使用场景：**由于vue有$parent属性可以让子组件访问父组件。但孙组件想要访问祖先组件就比较困难。通过provide/inject可以轻松实现**跨级访问父组件**的数据

**总结**：

provider/inject：简单的来说就是在父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量

需要注意的是这里不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据。

## vue路由的两种模式，hash与history

hash模式会在url地址栏中出现一个#号，跳转至别的路由页面会显示在地址栏上，浏览器会记录历史行为，刷新页面不会报错

history模式去掉了#号，跳转路由页面不会显示在地址栏中，项目上线需要后端支持，否则刷新页面会报错404，为什么会出现404，是因为加载了别的路径导致没有页面

## require和import区别

require 是赋值过程并且是运行时才执行， import 是解构过程并且是编译时执行。

require可以理解为一个全局方法，所以它甚至可以进行下面这样的骚操作，是一个方法就意味着可以在任何地方执行。而import必须写在文件的顶部。

require的性能相对于import稍低，因为require是在运行时才引入模块并且还赋值给某个变量，而import只需要依据import中的接口在编译时引入指定模块所以性能稍高

## ref与$refs的使用

> ref可以给一个DOM对象或者组件添加一个引用（标记）
>
> 通过this.$refs可以获取到当前组件中所有的引用，标记

## watch和computed的区别

**计算属性computed : **

\1. 支持缓存，只有依赖数据发生改变，才会重新进行计算

\2. 不支持异步，当computed内有异步操作时无效，无法监听数据的变化

3.computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值

\4. 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed

5.如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。

**侦听属性watch：**

\1. 不支持缓存，数据变，直接会触发相应的操作；

2.watch支持异步；

3.监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；

\4. 当一个属性发生变化时，需要执行对应的操作；一对多；

\5. 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，

　　immediate：组件加载立即触发回调函数执行，

　　deep: 深度监听，为了发现**对象内部值**的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。

## watch监听

监听属性：（侦听器）当需要监听一个数据变化的时候，数据变化会触发我们一定逻辑的时候

​    监听属性写在： 

​      1、watch 对象里。

​      2、监听属性我们写成一个方法

​      3、监听属性 的属性名 就是我们要监听的 data中的属性名。

​    要监听复杂类型 如对象 、数组，我们需要用到 监听属性的.完整写法。

​      对象

watch: {

* 

​        参数一：当前的值

​        参数二：以前的值

​        */

​        money(newValue, oldValue) {

​          console.log(newValue, oldValue)

​        },

​        // girlFriend(value) {

​        //   console.log(value)

​        // }

​        girlFriend: {

​          // 深度监听， 要监听对象内部的属性 需要深度监听。

​          deep: true,

​          // 立即马上，会在页面渲染的时候就会监听一次。

​          // immediate: true,

​          // handler 数据变化触发的方法

​          handler: function(value) {

​            console.log(value)

​          }

​        }

​      }

## vue双向数据绑定无法监听数组或者对象

**由于数据响应原理机制， Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明所有可能用到的根级响应式属性，且为这些属性都设一个初值，哪怕只是一个空值。**

数组

this.$set(array, index, data) 

对象

对象和数组都是js里的引用类型，在实际存储中，数据是存储在堆中的，利用存储在栈里的对象名或者数组名的指针进行索引，因此也存在在浅拷贝和深拷贝以及等号赋值时，到底是仅仅新建了一个指针指向了同一份数据，还是两个指针分别指向了两份完全一样的数据的问题

对象属性的增删改无法监听

解决：

- this.$set(obj, key ,value) - 可实现增、改
- watch时添加deep：true深度监听，只能监听到属性值的变化，新增、删除属性无法监听

## 数据双向绑定原理

vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty() 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。

vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 {{}}），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —>视图更新；视图交互变化（input）—>数据model变更双向绑定效果。

## 双向数据绑定get, set

const data = {

​      msg: 'hello'

​    }

​    let msg = data.msg

​    /* 

​    参数一：要劫持的属性所在的对象。

​    参数二：要劫持的属性名 ，字符串。

​    参数三：是一个对象，里面定义get 和 set方法

​     */

​    Object.defineProperty(data, 'msg', {

​      /* 

​      获取属性值的时候 走get方法。 data.msg

​       */

​      get() {

​        console.log('get被访问')

​        return msg

​      },

​      /* 

​      设置属性值的时候 会执行set方法。data.msg = 

​       */

​      set(value) {

​        msg = value

​        // 也会造成死循环

​        // data.msg = value

​      }

​    })

## vue3.0新特性

Performance：性能比vue2.x块1.2～2倍
Tree shaking support：支持按需编译，体积更小
Composition API：组合API，类似React Hooks
Custom Renderer API：暴露了自定义渲染API
Fragment，Teleport（Protal），Suspense：新增三个组件
Better TypeScript support：更好的支持TS

### Composition API

Vue2.x中，我们通常采用mixin来复用逻辑代码，使用起来虽然方便，但也存在一些问题：代码来源不清晰、方法属性可能出现冲突。因此，Vue3.x引入了Composition API（组合API），使用纯函数分割复用代码。和React Hooks的概念相似。

更好的逻辑复用和代码组织
更好的类型推导

### Fragment、Teleport、Suspense

新增三个组件。

Fragment
在书写Vue2.x时，由于组件必须是一个根结点，很多时候会添加一些没有意义的节点用于包裹。Fragment组件就是用于解决这个问题的（这和React 中的Fragment组件是一样的）。

Teleport
Teleport其实就是React中的Portal。Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。

一个 portal 的典型用例是当父组件有 overflow: hidden 或 z-index 样式时，但你需要子组件能够在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框。

Suspense
同样的，这和React中的Supense是一样的。

Suspense 让你的组件在渲染之前进行“等待”，并在等待时显示 fallback 的内容。



### Custom Renderer API

这个API定义了虚拟DOM的渲染规则，这意味着使用自定义API可以达到跨平台的目的。

### 最后：Vue3.0 是如何变快的？

#### diff 算法优化

Vue2 中的虚拟dom 是进行全量对比
Vue3 新增静态标记
hoistStatic 静态提升

Vue2 中无论元素是否参与更新，每次都会重新创建，然后在渲染
Vue3 中对于不参与更新的元素，会做静态提升，只被创建一次，在渲染时直接复用即可
cacheHandlers 事件侦听器缓存

默认情况下默认情况下onClick会被视为动态绑定，所以每次都会去追踪它的变化，但是因为是同一个函数，所以没有追踪变化，直接缓存起来复用即可
ssr 渲染

当有大量静态的内容的时候，这些内容会被当作纯字符串推进一个buffer里面，即使存在动态的绑定，会通过模版插值嵌入进去，这样会比通过虚拟dom来渲染的快上很多很多
当静态内容大到一定量级的时候，会用_createStaticVNode方法在客户端去生成一个static node。这些静态node，会被直接innerHtml，就不需要创建对象，然后根据对象渲染。

## 虚拟DOM

JS对象，里面包含一些DOM的主要信息，根据虚拟DOM生成真实DOM，数据改变，模板和数据生成新虚拟DOM

对比新旧虚拟DOM更新真实的DOM

## diff算法

diff算法的作用：找到两个虚拟DOM的不一样的地方，确定如何更新DOM

如果根元素发生了改变, 直接销毁原来的DOM，渲染新的DOM

根元素相同,属性不一样

根元素相同，对比孩子元素

子元素顺序变化  就地更新： diff算法默认按照下标对比

key的目的：提供更新的性能，，，，，为了diff算法更好的复用，，，因为如果没有给key，默认按照数组的下标进行对比，如果数组的元素顺序发生了改变，更新性能比较低。





## vue过滤器

语法：{{ msg |  过滤器}}

定义过滤器：

​			参数一：过滤器名字，参数二：一个函数处理过滤数据需要参数定义为input，还需要返回过滤结构

Vue.filter('aa'，function(input) {

​	return   input.一个方法

​	})

## vue中$router和$route的区别

​	$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。而$router是“路由实例”对象包括了路由的跳转方法，钩子函数等

## vue-router 传参

(1)使用Params:

- 只能使用name
- 参数不会显示在路径上
- 浏览器强制刷新参数会被清空

（2）使用Query：

- 参数会显示在路径上，刷新不会被清空
-  可以使用path路径

## vue路由中的钩子函数

全局前置守卫：beforeEach

全局后置钩子: afterEach

路由独享守卫: beforeEnter

组件内的守卫: beforeRouterEnter,beforeRouterUpdate,beforeLeave

from,to,next三个参数，from是从哪来，一般不考虑，to是去哪里进行逻辑判断，next是放行

## keep-alive和destroy

keep-alive可以让当前组件或者路由不经历创建和销毁，而是进行缓存，凡是被keep-alive组件包裹的组件，除了第一次以外。不会经历创建和销毁阶段的。第一次创建后就会缓存到缓存当中

通过include属性设置需要缓存的组件

如果某个组件需要被缓存，一定要给该组件提供name属性

destroy卸载所有的数据监听，组件，事件监听，vue对象销毁

## 父子通讯

1.父传子 ：

​      1、在调用子组件的时候，可以在子组件的标签上 添加自定义属性来传递参数

​      2、子组件通过props 数组，来接收 父组件传递过来的参数。

​      3、调用子组件时 自定义属性名 要和 子组件 中 props 接收的参数名一致。

2.子传父

​        子组件：

​          1、子组件准备数据

​          2、子组件 通过$emit方法 ，触发一个当前组件上的自定义事件，并传递参数给父组件。

​        父组件：

​          1、父组件绑定子组件触发的自定义事件。并指定事件执行的函数。

​          2、事件执行的函数中，接收子组件传递过来的参数。

​      $emit()： 触发当前组件自身的一个事件。

​        参数一：定义自定义事件名。可以不是click dblclick 之类的。

​        参数二：传递参数

## 非父子组件通信

### 	方法1：Global Event Bus （小型应用）

​		通过给eventbus注册事件，别的组件触发事件，实现通信。

​		1.创建一个eventbus对象，即创造一个vue对象，用作传递信息。

​		2.接收信息的一方将事件通过vm.$on(“事件名”,事件处理函数)添加在eventbus对象上。

​		3.发送数据的一方，通过vm.$emit(“事件名”,传递的数据)触发事件，将数据传递。

### 	方法2：VueX （大型应用）

## Vuex是什么？

VueX 是一个专门为 Vue.js 应用设计的状态管理架构，统一管理和维护各个vue组件的可变化状态(你可以理解成 vue 组件里的某些 data )。

Vue有五个核心概念，`state`, `getters`, `mutations`, `actions`, `modules`。本文将对这个五个核心概念进行梳理。

## 总结

state => 基本数据
getters => 从基本数据派生的数据
mutations => 提交更改数据的方法，同步！
actions => 像一个装饰器，包裹mutations，使之可以异步。
modules => 模块化Vuex

## State

state即Vuex中的基本数据！

#### 单一状态树

Vuex使用单一状态树，即用一个对象就包含了全部的状态数据。`state`作为构造器选项，定义了所有我们需要的基本状态参数。

#### mapState辅助函数

当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键。

#### 对象展开运算符

对象运算符
`...` 展开运算符（spread operator）允许一个表达式在某处展开。展开运算符在多个参数（用于函数调用）或多个元素（用于数组字面量）或者多个变量（用于解构赋值）的地方可以使用。

展开运算符不能用在对象当中，因为目前展开运算符只能在可遍历对象（iterables）可用。iterables的实现是依靠[Symbol.iterator]函数，而目前只有Array,Set,String内置[Symbol.iterator]方法，而Object尚未内置该方法，因此无法使用展开运算符。

#### 组件仍然保有局部状态

使用 Vuex 并不意味着你需要将所有的状态放入 Vuex。虽然将所有的状态放到 Vuex 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。

## getters

即从store的`state`中派生出的状态。

getters接收state作为其第一个参数，接受其他 getters 作为第二个参数，如不需要，第二个参数可以省略

可以认为是store的计算属性，它的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生改变了，才会被重新计算

#### mapGetters 辅助函数

mapGetters 辅助函数仅仅是将 store 中的 getters 映射到局部计算属性，与state类似

## mutations

提交mutation是更改Vuex中的store中的状态的唯一方法。

mutation必须是同步的，如果要异步需要使用action。

每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数，提交载荷作为第二个参数。（提交荷载在大多数情况下应该是一个对象）,提交荷载也可以省略的。

### Mutations 需遵守 Vue 的响应规则

- 最好提前在你的 store 中初始化好所有所需属性。
- 当需要在对象上添加新属性时，你应该
  - 使用 `Vue.set(obj, 'newProp', 123)`, 或者
  - 以新对象替换老对象。例如，利用对象展开运算符我们可以这样写`state.obj = {...state.obj, newProp: 123 }`

### mapMutations 辅助函数

与其他辅助函数类似，你可以在组件中使用 this.$store.commit(‘xxx’) 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。

### actions

Action 类似于 mutation，不同在于：

- Action 提交的是 mutation，而不是直接变更状态。
- Action 可以包含任意异步操作。

**注意：Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象**，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。

## Modules

使用单一状态树，导致应用的所有状态集中到一个很大的对象。但是，当应用变得很大时，store 对象会变得臃肿不堪。

为了解决以上问题，Vuex 允许我们将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割：

### 模块的局部状态

对于模块内部的 `mutation` 和 `getter`，接收的第一个参数是模块的局部状态,对于模块内部的 getter，根节点状态会作为第三个参数:

同样，对于模块内部的 action，`context.state` 是局部状态，根节点的状态是 `context.rootState`

## vuex的数据传递流程

当组件进行数据修改的时候，我们需要调用dispatch来触发actions里面的方法。actions里面的每一个方法都会有一个commit方法，当方法执行的时候会通过commit来触发mutations里面的方法进行数据修改。mutations里面的每个函数都会有一个state参数，这样就可以在mutations里面进行state的数据修改，当数据修改完毕后，会传导给页面，页面数据就会发生改变

# 项目问题

## 登陆界面token问题

登录功能使用的使用 token做的，为什么使用token？

后台返回是token，session+cookie 只适合前后端不分离项目，我们的项目是分离的

前端处理token是登陆成功之后把token存在localStorage中，每次发请求带上

## 什么是跨域，什么是同源策略，解决跨域的方法

当一个请求url的**协议、域名、端口**三者之间任意一个与当前页面url不同即为跨域

同源策略就是指的是协议，域名，端口相同

解决跨域方法：

1.通过Jsonp跨域，但是只支持get请求

2.CORS后端设置

3.反向代理

## JSONP原理

ajax请求受同源策略影响，不允许进行跨域请求，而script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。

## 反向代理

url地址发送请求如果使用绝对路径，请求直接发送，但是是相对路径，url会拼接当前项目的路径，使用基准地址发送请求，没有跨域是因为，后端设置了cors，一旦后端没有设置，就会发生跨域问题。

webpack中有deserver可以帮我们拿资源

 proxy: {

 	代理规则/api

​        '/api': {

​	命中规则，需要把路径代理到指定服务器

​          target: 'http://localhost:3000',

​	把/api重写为空

​          pathRewrite: { '^/api': '' },

​          secure: true

​        }

​      }

把基准路径改为"/api"

## 接口配置问题

> 前后端是分离的，分开开发。
>
> 项目中跨域了怎么办？

- jsonp：不用  只能get请求  script标签不会受到同源策略的影响
- cors:  跨域资源共享   ajax XMLHttpRequest 2.0  允许ajax跨域
  - 需要后台配置响应头
- 反向代理： 服务器和服务器发请求不会跨域的
- 在`vue.config.js`中配置反向代理

```js
// 反向代理
proxy: {
  // 配置的代理规则，，，只要是以 /api开头的url地址都会被代理
  // https://localhost:8081/api/login
  // https://localhost:3000/api/login
  '/abc': {
    target: 'http://localhost:3000',
      pathRewrite: { '^/abc': '' },
        // 代理到https协议下
        secure: true
  }
}
```

- 修改接口的基准地址

```js
axios.defaults.baseURL = '/abc'
```



==注意：webpack的反向代理只有在项目开发阶段有用， 项目上线了，webpack的服务器就失效了，代码上传真正的服务器==

apache  node nginx

## 防抖和节流

防抖：一个函数需要延迟一段时间才会执行，但是如果在这个时间内，这个函数触发了，需要重新计时

// 函数防抖

​        var input = document.querySelector('input')

​        var timer = null

​        input.oninput = function () {

​            clearInterval(timer)

​            timer = setTimeout(() => {

​                console.log(input.value);

​            }, 1000)

​        }

适用于input输入框，resize事件不断调整浏览器窗口大小触发事件，用防抖只触发一次

节流：规定在一个单位时间内，只能触发一次函数，如果这个单位时间内触发多次函数，只有一次生效

// 函数节流

​        var input = document.querySelector('input')

​        var flag = true

​        input.oninput = function () {

​            if (flag) {

​                flag = false

​                console.log(input.value);

​                setTimeout(() => {

​                    flag = true

​                }, 1000)

​            }

​        }

轮播图点击下一张，多次点击，上拉加载，拉到底部不能在拖动

## 本地存储

1.sessionStorage
优点：可以临时存储，关闭页面标签自动回收，不支持跨页面交互
缺点：只能作为临时存储，不能存储持久化
2.localStorage
优点：用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去删除。
缺点：存在大小限制，IE8以上的IE版本才支持这个属性；目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换
3.cookie
优点：兼容性最好，几乎所有的浏览器都支持
缺点：大小有限制，而且每次发送请求，请求头里会带着cookie一起发过去，现在基本大多数登录的合法性验证都是用cookie验证的
4.userData
优点：出现的时间比sessionStorage要早
缺点：IE专门的存储方式，存储大小有限，单个文件的大小限制是128KB，一个域名下总共可以保存1024KB的文件，文件个数应该没有限制。在受限站点里这两个值分别是64KB和640KB

cookie + session:  cookie 携带信息发送给服务器，服务器返回sessionid，下次登陆时看是否有sessionid，没有则

重新获取进行登录。缺点：cookie 只有4kb且不能跨域

## 浏览器渲染机制

浏览器渲染页面的一般过程：

1.浏览器解析html源码，然后创建一个 DOM树。并行请求 css/image/js在DOM树中，每一个HTML标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。DOM树的根节点就是 documentElement，对应的是html标签。

2.浏览器解析CSS代码，计算出最终的样式数据。构建CSSOM树。对CSS代码中非法的语法它会直接忽略掉。解析CSS的时候会按照如下顺序来定义优先级：浏览器默认设置 < 用户设置 < 外链样式 < 内联样式 < html中的style。

3.DOM Tree + CSSOM --> 渲染树（rendering tree）。渲染树和DOM树有点像，但是是有区别的。

DOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素等。而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的css属性。

4.一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。

以上四个步骤并不是一次性顺序完成的。如果DOM或者CSSOM被修改，以上过程会被重复执行。实际上，CSS和JavaScript往往会多次修改DOM或者CSSOM

# 优化

## 项目上线优化

1.清除闲置依赖包

2.依赖优化 CDN 加速

3.gzip暴力压缩

4.对于第三方库进行按需加载

项目打包：yarn build

打包完把dist文件夹下面所有内容放在www目录下

第三方资源库使用按需加载

BootCDN网站可以免费使用

CDN优化第三方资源：在index.html中引入第三方库cdn地址

通过webpack的配置，排除打包的依赖项

## 性能优化

1.尽量减少http请求

2.避免在CSS中使用Expression

3.添加expire/Cache-Control

4.减少使用全局变量，缓存DOM节点查找的结果，减少IO读取操作

5.图片预加载，将样式表放在顶部，将脚本放在底部，加上时间戳

6.当需要设置很多样式时，设置classname而不是直接操作style

7.用innerHTML代替DOM操作，减少DOM操作次数，优化JS性能

8.前端模板JS+数据，减少由于HTML标签导致的宽带浪费，前端使用变量保存

AJAX请求结果，每次操作本地变量，不用请求，减少请求的次数



## 前端缓存

缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。

### 为什么要缓存（缓存的优点）

缓解服务器压力（不用每次去请求资源）

提升性能，提高访问速度（打开本地资源速度当然比请求回来再打开要快得多）

减少网络 IO 消耗，减少带宽消耗

通过网络获取内容既速度缓慢又开销巨大

如果是较大的响应需要在客户端与服务器之间进行多次往返通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用

## 缓存类型

缓存总体可分为：私有缓存（private）与共享缓存（public）

私有缓存：该资源只能被浏览器缓存，private 为默认值，只能用于单独用户

共享缓存：该资源既可以被浏览器缓存，也可以被代理服务器缓存，能够被多个用户使用

按种类分的话可以分为：

数据库缓存

代理服务器缓存

网关缓存（CDN缓存）

浏览器缓存浏览器缓存机制

## HTTP 缓存策略（主要）

当客户端向服务器请求资源时，会先抵达浏览器缓存，当以上缓存都没有命中的时候，我们就需要发起请求获取资源了。当然为了性能考虑，我们肯定不希望所有的资源每次都是请求来的。所以需要给不同的资源选择不同的缓存策略。
然而常见的 HTTP 缓存只能存储 GET 响应，对于其他类型的响应则无能为力。
通常浏览器缓存策略分为三种：**强缓存，协商缓存和启发式缓存**，并且缓存策略都是通过设置 HTTP Header 来实现的。

### 强缓存

不会向服务器发送请求，直接从缓存中读取资源。

状态码：200，显示 from disk cache 或 from memory cache。

设置两种 HTTP Header 实现：Expires 和 Cache-Control。

### 协商缓存

当 Cache-Control 和 Expires 过期或者它的属性设置为no-cache时(即不走强缓存)，那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新。

如果服务器端的资源没有修改（Not Modified），那么就会返回304状态码，告诉浏览器可以使用缓存中的数据。

如果数据有更新就会返回200状态码，服务器就会返回更新后的资源并且将缓存信息一起返回。

### 启发式缓存

如果Expires，Cache-Control: max-age，或 Cache-Control:s-maxage都没有在响应头中出现，并且设置了Last-Modified时，那么浏览器默认会采用一个启发式的算法，即启发式缓存：根据响应头中2个时间字段 Date 和 Last-Modified 之间的时间差值，取其值的10%作为缓存时间周期。这是浏览器默认的缓存方式

## Vue首屏加载优化

路由懒加载：异步组件和按需加载

const xxx = () => import('...')

但是文件太多

优化：给每一个路由组件添加名字，即可打包至同一个文件中

## webSorket

WebSocket是一种通信协议，可在单个TCP连接上进行全双工通信。WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就可以建立持久性的连接，并进行双向数据传输。

```avrasm
Upgrade: websocket
Connection: Upgrade
```

这就是websocket的核心，告诉服务器这是websocket请求，而不是http请求

其余的特点有：

- 握手阶段采用 HTTP 协议。
- 数据格式轻量，性能开销小。客户端与服务端进行数据交换时，服务端到客户端的数据包头只有2到10字节，客户端到服务端需要加上另外4字节的掩码。HTTP每次都需要携带完整头部。
- 更好的二进制支持，可以发送文本，和二进制数据
- 没有同源限制，客户端可以与任意服务器通信
- 协议标识符是ws（如果加密，则是wss），请求的地址就是后端支持websocket的API。

### **AJAX轮询**

AJAX轮询也就是定时发送请求，也就是普通的客户端与服务端通信过程，只不过是无限循环发送，这样，可以保证服务端一旦有最新消息，就可以被客户端获取。

### **Long Polling长轮询**

Long Polling长轮询是客户端和浏览器保持一个长连接，等服务端有消息返回，断开。
然后再重新连接，也是个循环的过程，无穷尽也。。。

客户端发起一个Long Polling，服务端如果没有数据要返回的话，
会hold住请求，等到有数据，就会返回给客户端。客户端又会再次发起一次Long Polling，再重复一次上面的过程。

### **缺点**

上边这两种方式都有个致命的弱点，开销太大，被动性。假设并发很高的话，这对服务端是个考验。
而WebSocket一次握手，持久连接，以及主动推送的特点可以解决上边的问题，又不至于损耗性能。



# Vue和React区别

虽然Vue和React两者在定位上有一些交集，但差异也是很明显的。

**Vue 使用的是 web 开发者更熟悉的模板与特性**，Vue的API跟传统web开发者熟悉的模板契合度更高，比如Vue的单文件组件是以模板+JavaScript+CSS的组合模式呈现，它跟web现有的HTML、JavaScript、CSS能够更好地配合。**React 的特色在于[函数式编程](https://www.zhihu.com/search?q=函数式编程&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1066629375})的理念和丰富的技术选型**。Vue 比起 React 更容易被[前端工程师](https://www.zhihu.com/search?q=前端工程师&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1066629375})接受，这是一个直观的感受；React 则更容易吸引在 FP 上持续走下去的开发者。

从**使用习惯和思维模式**上考虑，对于一个没有任何Vue和React基础的web开发者来说， Vue会更友好，更符合他的思维模式。React对于拥有函数式编程背景的开发者以及一些并不是以web为主要开发平台的开发人员而言，React更容易接受。这并不意味着他们不能接受Vue，Vue和React之间的差异对他们来说就没有web开发者那么明显。可以说，**Vue更加注重web开发者的习惯**。

**实现上，Vue跟React的最大区别在于数据的reactivity，就是反应式系统上。**Vue提供反应式的数据，当数据改动时，界面就会自动更新，而React里面需要调用方法SetState。我把两者分别称为**[Push-based](https://www.zhihu.com/search?q=Push-based&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1066629375})**和**Pull-based**。所谓Push-based就是说，改动数据之后，数据本身会把这个改动推送出去，告知渲染系统自动进行渲染。在React里面，它是一个Pull的形式，用户要给系统一个明确的信号说明现在需要重新渲染了，这个系统才会重新渲染。两者并没有绝对的优劣之分，更多的也是思维模式和开发习惯的不同。

两者不是完全互斥的，比如说在React里面，你也可以用一些第三方的库像MobX实现Push-based的系统，同时你也可以在Vue2.0里面，通过一些手段，比如把数据freeze起来，让数据不再具有反应式特点，或者通过手动调用组件更新的方法来做一个pull-based系统。所以两者并没有一个绝对的界限，只是默认的倾向性不同而已。

