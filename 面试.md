#### Cookie,sessionStorage,LocalStorage

服务器端通信，cookie由服务器端写入，在前端给后端发展送请求时会自动携带，每次都会以请求头的形式发送，如果使用cookie保存过多数据会带来性能问题，cookies在同一域名domain限制20个。

数据生命周期，cookie可以设置失效时间，默认是浏览器关闭后失效，cookie的生命周期是在服务器端被写好了的，localStorage除非被清除，否则永久性保存，sessionStorage仅在当前会话下有效，关闭浏览器被清除。

#### axios

对xhr的封装，返回promise对象

设置拦截器

取消请求，abort

自动转换json数据

对于大型项目来说，封装axios一些共同的配置是很有必要的。

axios.defaults.baseUrl  请求源的封装

axios.defaults.headers  设置通用请求头

axios.default.timeout    设置请求超时时间

#### localStorage超过了大小怎么处理

localStorage存储不是5m是每个域5M

超过了申请其他的域/修改ng配置，postmessage通信往其他域上存取

#### for...in可以遍历原型上的属性和方法吗

for...in可以遍历原型上的属性和方法，还可以遍历自身非不可遍历和symbol的属性和方法

#### 实现圣杯布局

父盒子设置flex布局，子盒子设置属性flex：1，

#### position的属性值有哪些

static：默认正常布局，z-index等都无效；

relative：相对定位，这个定位一般和absolute搭配使用，相对定位不会破坏元素的文档流，但是会改变元素的视觉效果

absolute:根据父盒子进行绝对定位，会脱离文档流

stiky：粘性定位，粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。

fixed：固定定位，在滚动屏幕位置的时候元素位置不会改变。在固定顶部导航栏的时候可以使用这个属性。

#### 如果给一个元素设置absolute会发生什么

1. 脱离文档流
2. 设置了定位将按照定位量偏移

#### JS的数据类型

number

object

boolean

undefined

null

string

symbol

object引用类型

#### 如何去检测数据类型

可以通过typeof返回一些基本数据类型，但是typeof不能判断null，会认为null属于object，所以需要加一个判断添条件，或者通过对象可以通过obejct.prototype.toString.call(obj)更加精确，还可以通过'=='instanceof等判断语句来判断类型

#### new一个对象的中间过程

在 JavaScript 中，使用 `new` 运算符创建一个新的对象时，会执行以下中间过程:

1. 创建一个空对象:`new` 运算符会创建一个新的空对象，这个对象的属性值为 `undefined`。
2. 填充对象属性：使用对象字面量或者属性名称和值来填充对象的属性。例如:`{ foo: 'bar' }` 或者 `{ foo: 'bar' } = new Object()`。
3. 初始化对象属性：对于对象属性，JavaScript 会按照以下规则进行初始化:
   - 如果属性是可选的，则使用 `undefined` 进行初始化。
   - 如果属性是必须的，则使用对象的默认值进行初始化，如果默认值是 `false`,则将该属性的值设置为 `false`。
   - 如果属性是布尔类型，则使用 `true` 或 `false` 进行初始化。
   - 如果属性是字符串类型，则使用该字符串的值进行初始化。
   - 如果属性是数字类型，则使用该数字的值进行初始化。
   - 如果属性是日期类型，则使用该日期的值进行初始化。
   - 如果属性是函数类型，则创建一个新的函数对象，该对象的 [[Function]] 属性指向该函数。
4. 返回新的对象：当所有中间过程完成之后，`new` 运算符会返回新创建的对象。

#### 展开说说js的箭头函数

es6新特性，箭头函数的this指向是固定的，不会随着call，apply等改变this指向，所以箭头函数不能用于构造函数等这些this指向可变的函数，当this函数只有一个参数时可以简写不要括号，返回单一语句是也可以直接写，箭头函数时匿名函数，当返回值是一个对象时，简写方式需要在外面包一个括号



#### promise的理解，它解决了什么问题

promise是es6的新特性，Promise用于处理一些需要花费长时间的任务，进行异步处理，防止任务阻塞。一般是说解决了回调地狱的问题。

Promise 是异步编程的一种解决方案，其实就是一个构造函数，自己身上有all、resolve、reject这几个方法，原型上有.then、.catch等方法。

promise有三种状态： pending(等待态)，fulfiled(成功态)，rejected(失败态)。



#### 防抖节流的应用场景

防抖将多次点击只执行最后一次

节流多次点击少量指向

滚动事件节流，

验证码防抖，提交表单防抖，轮播图防抖。



#### vue2中那个生命周期存在真实的dom了

mounted



#### watch和computed的区别，应用场景

##### computed

compoted不支持异步，因为computed是直接计算根据返回值定值的，computed走的是缓存，在解析时会被调用求一次值，直到computed内部依赖的数据改变从而再次调用求值，同时重写渲染使用这个computed的地方。

computed用于封装复杂的计算，或者依赖于vue内部的响应式的数据的计算。

##### watch

watch支持异步但是不支持缓存，watch监听数据或者属性当属性或数据改变时，会调用写入的回调函数，回调函数接受两个参数，第一个为新值，第二个为旧值

监听的数据必须是响应式的

当一个数据改变需要执行多个操作时，考虑使用watch



#### v-model原理

`·v-model`是一个指令，限制在`<input>、<select>、<textarea>、components`中使用

采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。执行updata（）

首先判断元素节点是否有`v-model`属性，`v-model`的属性值进行`trim`去空格,当vue响应式内部没有这个属性值的响应是数据式，则不进行任何后续，当有时增加监听事件，当回调时吧响应式数据变为该数据。从而实现数据的双向绑定



#### 对vuex的理解

vuex是一个全局状态管理插件，



#### 什么是HTML语义化？

“语义化”指的是在需要更少的人类干预的情况下，能够研究和手机信息，让网页能够被机器理解，最终让人类受益。

语义化的目的就是让大家直观的认识标签（markup）和属性（attribute）的用途和作用。很明显Hx系列看起来很像标题，因为拥有粗体和较大的字号。<strong>,<em>用来区别于其他文字，起到了强调的作用。至于列表和表格很明显的告诉你他们是做什么的。

#### HTML语义化有什么好处？

语义化的网页的好处，最主要的就是对搜索引擎友好，有了良好的结构和语义你的网页内容自然容易被搜索引擎抓取，你网站的推广便可以省下不少的功夫。

语义 Web 技术有助于利用基于开放标准的技术，从数据、文档内容或应用代码中分离出意义。

#### 为什么要HTML语义化？

- 在没有css的情况下，页面也能呈现出比较好的内容结构、代码结构。
- 用户体验较好：例如：label标签的活用、title、alt用于解释名词或解释图片。
- 方便其他设备解析（阅读器、移动设备）以意义的方式来渲染网页。
- 便于团队维护：语义化的HTML更具可读性，团队遵循W3C标准。
- 有利于SEO：和搜索引擎建立友好的交流，有利于爬虫抓取更多的有效信息。

#### HTML语义化标签

- **header元素**

 该元素是网页或者section的页眉部分，通常包含h标签，包括网站标志、全局导航、全站链接、搜索框等。

也可以包含一节的目录或者nav或者相关的logo。

一个页面可以有多个header标签。

eg、

```
<header>
    <hgroup>
        <h1>网站标题</h1>
        <h1>网站副标题</h1>
    </hgroup>
</header>
```

- **title元素**

该元素用来简短的描述网页内容，在页面中唯一存在。

搜索引擎会将title作为判断页面主要内容的指标，有效的title应该包含几个与页面内容密切相关的关键字，建议将title核心内容放在前60个字符中。



#### 黑白帽SEO

##### 白帽SEO

是一种通过公正的手段，符合主流搜索引擎的思维方法

##### 黑帽SEO

是一种使用搜索引擎所禁止的的方式，快速的增加网站的排名，可能随时因为搜索引擎算法的改变而面临惩罚



#### 实现换肤功能的思路

1. 写入不同的样式类名，通过切换类名实现换肤
2. 关键颜色采用css变量，通过修改css变量实现换肤
3. 实现多套主题样式文件，通过link标签动态加载不同文件实现换肤



#### 伪类和伪元素的区别

伪元素:用于创建一些不存在文档树的元素,并为其添加样式;比如我们可以通过:before在一个元素前增加一些文本并为其添加样式;用户可以看到这些样式,但其并不存在于文档树中

伪类:用于当某个元素处于某个状态时为其添加样式,这个状态是根据用户状态变化的;比如当鼠标悬停时我们通过:hover来描述这个元素的状态;它虽和css类似,但只有处于dom树无法描述的状态时才能为其添加样式

区别:

伪类是操作处于文档树中的元素

伪元素是创建一个文档树之外的元素



#### 如何将对象转换为json？如何让这个json格式化？

js中通常采用`JSON.stringify()`可以方便的将js对象转换为json，格式化json可以便于我们阅读json数据，`json.stringify`提供的第二个和第三个参数可以很好的将json格式成便于阅读的形式

```javascript
var obj = {  
  name: "John",  
  age: 30,  
  hobbies: ["reading", "swimming", "traveling"]  
};

// 将对象转换为 JSON 字符串  
var json = JSON.stringify(obj, null, 4);
```



#### vue的事件队列机制（异步渲染）  ？？？



#### package.json的作用

`package.json` 文件是 Node.js 应用程序的重要配置文件，它提供了有关应用程序的依赖项、版本号、作者信息、描述等信息，这些信息对于正确地安装、更新和维护应用程序至关重要。



#### package.json中版本号的规则

一、版本的格式

major、minor、patch分别是主版本号、次版本号、修补版本号

patch：修复bug，兼容老版本

minor：新增功能，兼容老版本

major：新的架构调整，不兼容老版本
二、依赖版本号规则

这三个依赖分别使用了三个符号来表明依赖的版本范围。语义化版本范围规定：

    *：升级到最新版本
    ^：升级次版本号和修订号
    ~：只升级修订号

1. 必须匹配某个版本

       如：1.1.2，表示必须依赖1.1.2版

2. \>version


        必须大于某个版本
        如：>1.1.2，表示必须大于1.1.2版

3.  \>=version


        可大于或等于某个版本
        如：>=1.1.2，表示可以等于1.1.2，也可以大于1.1.2版本

4. <version


        必须小于某个版本
        如：<1.1.2，表示必须小于1.1.2版本

5. <=version


        可以小于或等于某个版本
        如：<=1.1.2，表示可以等于1.1.2，也可以小于1.1.2版本

6. ~version


        大概匹配某个版本
    
        如果minor版本号指定了，那么minor版本号不变，而patch版本号任意
    
        如果minor和patch版本号未指定，那么minor和patch版本号任意
    
        如：~1.1.2，表示>=1.1.2<1.2.0，可以是1.1.2，1.1.3，1.1.4，…，1.1.n
    
        如：~1.1，表示>=1.1.0 <1.2.0，可以是同上
    
        如：~1，表示>=1.0.0<2.0.0，可以是1.0.0，1.0.1，1.0.2，…，1.0.n，1.1.n，1.2.n，…，1.n.n

7. ^version


        兼容某个版本
        版本号中最左边的非0数字的右侧可以任意
        如果缺少某个版本号，则这个版本号的位置可以任意
        如：^1.1.2 ，表示>=1.1.2
        <2.0.0，可以是1.1.2，1.1.3，…，1.1.n，1.2.n，…，1.n.n
        如：^0.2.3 ，表示>=0.2.3 <0.3.0，可以是0.2.3，0.2.4，…，0.2.n
        如：^0.0，表示 >=0.0.0 <0.1.0，可以是0.0.0，0.0.1，…，0.0.n

8. x-range


        x的位置表示任意版本
        如：1.2.x，表示可以1.2.0，1.2.1，…，1.2.n

9. *-range


        任意版本，""也表示任意版本
        如：*，表示>=0.0.0的任意版本

10. version1 - version2


        大于等于version1，小于等于version2
        如：1.1.2 - 1.3.1，表示包括1.1.2和1.3.1以及他们件的任意版本

11.range1 || range2


        满足range1或者满足range2，可以多个范围
        如：=2.3.1 =2.5.2 .0.0，表示满足这3个范围的版本都可以


#### css盒子模型

分为两种，一种为普通盒模型，普通盒模型的`box-sizing`为content-box，意味着计算盒子宽度时，计算方式为

```
margin + padding + border + width
```

第二种为怪异盒模型，`box-sizing`为border-box，

```
margin + width
```

此时的怪异盒模型不会因为改变border，padding而增大，因为他们都被计算在了width里面，除非你的padding和border设置超出了原有的width。



#### box-sizing的属性

border-box，inherit，initial，content-box



#### flex布局常用的属性

flex：增长因子，缩减因子，基准因子的简写

display： 定义盒子为flex布局

flex-direction：定义flex的排列方向

ailgn-items：

*justify-content*：



#### 跨越有哪些方式

##### cors

##### 反向代理

##### jsonp



#### localStorage、sessionStorage同一网站下共享问题

以下都基于同源的前提

localStorage在同源下，不同标签页都可共享

sessionStorage在同源下分为两种情况

1. 浏览器打开A页面再通过A页面打开B页面，此时的A，B两个页面的sessionStorage是共享的。这里的共享指的是A页面在跳转时会把sessionStorage拷贝一份，作为B页面的初始值，此时改变B页面的sessionStorageA页面不受影响，即不同的页面间，sessionStorage读写操作独立，互不影响
2. 浏览器打开A页面，然后新开一个标签页访问B页面，此时，A，B两个页面的sessionStorage不共享。



#### JSON.parse(JSON.stringify(obj))

这是一个实现简单对象深复制的方法，但是由于json.stringify()的特性不能复制函数，symbol值的



#### http强缓存

强缓存，指的是 **让浏览器强制缓存服务端提供的资源**。

响应头字段 Cache-Control，通过设置 `max-age=<seconds>`，可以规定资源的缓存有效时间长度，单位为秒。



#### 协商缓存

协商缓存，是**在缓存过期的情况下，客户端和服务端协商，确认客户端缓存是否需要更新**。



#### async/await怎么捕获异常

对于少量可以直接使用try...catch，大量可以考虑封装try...catch,或者使用promise.all()



#### css高度塌陷

在文档流中，父元素的高度默认是被子元素所撑开的，也就是子元素多高，父元素就多高，但是当子元素设置了浮动时，子元素就脱离了文档流，此时的子元素无法撑起父元素的高度，导致父元素高度塌陷，



#### 怎么解决css高度塌陷

1. 给父盒子一个固定的高度

2. 给父盒子设置`overflow: hidden`

3. 在子元素的末尾添加一个div并设置下列样式

   ```
   div{
   	clean: both;
   	height: 0px;
   	overflow: hidden;
   }
   ```

   
